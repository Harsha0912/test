#  File: Spiral.py
#  Student Name: Alejandro Zamudio
#  Student UT EID: az8565
#  Partner Name: Sriharsha Kondapalli
#  Partner UT EID: sk55955

import sys


# Input: n
# Output:
def get_dimension(in_data):
    
    currData = in_data.readline()
    currData = currData.strip()
    '''currData reads in the first line which is intended to be the size of the spiral.
    The read in data is then stripped of all white space that may have been inckuded within the string'''

    try:
        dimensionSize = currData
        dimensionSize = int(dimensionSize)
        #try will look to make the first read in value an integer
    except:
        print("Invaid Data")
        currData.readline()
        #if the value is not an integer and an exception is raised, code says invaid data ad reads the next line

    return dimensionSize


    


# Input: n is an odd integer between 1 and 100
# Output: returns a 2-D list representing a spiral
#         if n is even add one to n
def create_spiral(n):
    if(n % 2 == 0):
        n += 1
    #If the size is a even number, one is added to the size to make it odd

    nums = n ** 2
    x = n - 1
    y = 0
    #the amount of numbers is generated by taking the adjusted size and squaring it.
    #x and y are the coordinates of the start points for the method of creating the spiral, which start at the
    #top right point (First row, last column)

    currSpiral = list()
    for i in range(n):
        currSpiral = currSpiral + [([0] * n)]
    #currSpiral is first off set as a 2D list of n x n size. For loop places n lists of
    #n zeroes into the first list to create the 2D list

    currSpiral[(n//2)][(n//2)] = 1
    #One is placed in the middle of the 2D List

    for m in range(1, ((n//2)+1)):
    #The for loop is set in range from 1 to half the size plus one (integer division) as the spiral
    #woul require (n//2) + 1 full circles/squares to fill out the numbers around 1

        
        while(True):
            currSpiral[y][x] = nums
            if(x == 0 or currSpiral[y][x-1] != 0):
                break
            else:
                x -= 1
                nums -= 1
        #While on a top row (from 1) that isnt full of numbers, the numbers will be placed into it going from right to left.
        #Code looks to see if the spot next to it has a number in it or if it is at the edge of the 2D list, in those cases
        #the code breaks and ends the while

        
        while(True):
            currSpiral[y][x] = nums
            if(y == n-1 or currSpiral[y+1][x] != 0):
                break
            else:
                y += 1
                nums -= 1
        #While on a left column (from 1) that isnt full of numbers, the numbers will be placed into it going from top to bottom.
        #Code looks to see if the spot next to it has a number in it or if it is at the edge of the 2D list, in those cases
        #the code breaks and ends the while             


        while(True):
            currSpiral[y][x] = nums
            if(x == n - 1 or currSpiral[y][x+1] != 0):
                break
            else:
                x += 1
                nums -= 1
        #While on a bottom row (from 1) that isnt full of numbers, the numbers will be placed into it going from left to right.
        #Code looks to see if the spot next to it has a number in it or if it is at the edge of the 2D list, in those cases
        #the code breaks and ends the while        


        while(True):
            currSpiral[y][x] = nums
            if(y == 0 or currSpiral[y-1][x] != 0):
                break
            else:
                y -= 1
                nums -= 1

        x = n - (m+1)
        y = 0 + m
        nums -=1
        #While on a right column (from 1) that isnt full of numbers, the numbers will be placed into it going from bottom to top.
        #Code looks to see if the spot next to it has a number in it or if it is at the edge of the 2D list, in those cases
        #the code breaks and ends the while  


    return currSpiral
        
    


# Input: handle to input file
#        the number spiral
# Output: printed adjacent sums
def print_adjacent_sums(in_data, spiral):
    currData = in_data.readlines()
    currData = [x.strip() for x in currData]
    #currData reads in the remainder of the lines and eliniates any white space from the strings
    
    for i in currData:
        try:
            i = int(i)
        except:
            print("Invalid Data")
            continue
        print(sum_adjacent_numbers(spiral, i))
    #For every read in line, the code trys to convert the data into an integer. If an exception is raised,
    #the code prints a message and moves on to the next

    

# Input: the number spiral
#        the number to find the adjacent sum for
# Output: integer that is the sum of the
#         numbers adjacent to n in the spiral
#         if n is outside the range return 0
def sum_adjacent_numbers(spiral, n):
    if n > max(spiral[0]):
        return 0
    #First checks to make sure that the number is not above the range of the spiral

    for i in range(len(spiral)):
        if n in spiral[i]:
            j = spiral[i].index(n)
            point = [i, j]
   
    #For loops goes to each row and uses in to see if the value being searched for is within it. If it is found
    #the index will be returned and set as a point with the i in range as the row and j as the column
    touching = [[1,0],[1,1],[1,-1],[0,1],[0,-1],[-1,0],[-1,-1],[-1,1]]
    # These are all the indexes that are adjacent to the given point
    count = 0
    # This keeps track of the count of the adjacent numbers
    for i in touching:
        # This loops through all of the touching points and adds them to count
        try:
            k = (point[0]+i[0])
            j = (point[1]+i[1])
            if k >= 0 and j >= 0:
                # Makes sure that the point is positive to avoid negative indexes
                count += spiral[k][j]
        except:
            # If the index is out of range just skip it
            continue
        
    return count


                



# Added for debugging only. No changes needed.
# Do not call this method in submitted version of your code.
def print_spiral(spiral):
    for i in range(0, len(spiral)):
        for j in range(0, len(spiral[0])):
            row_format = '{:>4}'
            print(row_format.format(spiral[i][j]), end='')
        print()


''' ##### DRIVER CODE #####
    ##### Do not change, except for the debug flag '''


def main():

    # set the input source - change to False before submitting
    debug = False
    if debug:
        in_data = open('spiral.in')
    else:
        in_data = sys.stdin

    # process the lines of input
    size = get_dimension(in_data)

    # create the spiral
    spiral = [[]]
    spiral = create_spiral(size)

    # use following line for debugging only
    # print_spiral(spiral)


    # process adjacent sums
    print_adjacent_sums(in_data, spiral)


if __name__ == "__main__":
    main()
